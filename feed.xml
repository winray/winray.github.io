<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Winray Blog</title>
    <description>For study!</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 04 Mar 2016 11:35:46 +0800</pubDate>
    <lastBuildDate>Fri, 04 Mar 2016 11:35:46 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>Sicily 1034. Forest</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;网上很多说用深搜，很任性…….发现广搜也挺好用的，实验课打的(⊙o⊙)…orz……..囧。&lt;/li&gt;
      &lt;li&gt;先找根结点，根据根结点广搜深度，广搜宽度，不过要开一个数组，同一层的累加宽度。别忘了要判断是否合法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

bool path[101][101];
bool visited[101];
bool Root[101];

int main()
{
    int n, m;
    while (cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;amp;&amp;amp; n)
    {
        memset(path, false, sizeof(path));
        memset(visited, false, sizeof(visited));
        memset(Root, true, sizeof(Root));

        bool flag = n &amp;gt; m ? true : false;
        for (int i = 1; i &amp;lt;= m; i++)
        {
            int node1, node2;
            cin &amp;gt;&amp;gt; node1 &amp;gt;&amp;gt; node2;
            if (node1 == node2) flag = false;
            path[node1][node2] = true;
        }
        if (flag == false) {
            cout &amp;lt;&amp;lt; &quot;INVALID\n&quot;;
            continue;
        }
        
        for (int i = 1; i &amp;lt;= n; i++)
            for (int j = 1; j &amp;lt;= n; j++)
                if (path[j][i])
                    Root[i] = false;
        int maxwidth = 0;
        for (int i = 1; i &amp;lt;= n; i++)
            if (Root[i]) {
                maxwidth++;
                visited[i] = true;
            }
        queue&amp;lt;int&amp;gt; store;
        int depth, maxdepth;
        maxdepth = depth = 0;
        int width[101] = {0};
        for (int i = 1; i &amp;lt;= n; i++)
        {
            if (Root[i])
            {
                store.push(i);
                depth = 0;
                while (!store.empty())
                {
                    int size = store.size();
                    width[depth] += size;
                    while (size--)
                    {
                        for (int j = 1; j &amp;lt;= n; j++)
                            if (path[store.front()][j])
                            {
                                if (!visited[j]) {
                                    store.push(j);
                                    visited[j] = true;
                                }
                                else
                                    flag = false;
                            }
                        store.pop();
                    }
                    if (!store.empty())
                        depth++;
                }
                maxdepth = depth &amp;gt; maxdepth ? depth : maxdepth;
            }
        }
        
        for (int i = 1; i &amp;lt;= n; i++)
            if (!visited[i]) {
                flag = false;
                break;
            }
        
        for (int i = 0; i &amp;lt;= maxdepth; i++)
            maxwidth = width[i] &amp;gt; maxwidth ? width[i] : maxwidth;
        
        flag == false ? cout &amp;lt;&amp;lt; &quot;INVALID&quot; : cout &amp;lt;&amp;lt; maxdepth &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; maxwidth;
        cout &amp;lt;&amp;lt; endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily13/</link>
        <guid isPermaLink="true">/2016/03/04/sicily13/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1936. Knight Moves</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;这道题一开始不理解题意…orz…囧，看大神们理解的。&lt;/li&gt;
      &lt;li&gt;题意是说一个8*8的国际象棋，骑士以马的形式走动（“日”字型），指定两个点，输出最小的步骤。&lt;/li&gt;
      &lt;li&gt;可以利用广度搜索解决。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

int dx[] = {-1, -2, -2, -1, 1, 2, 2, 1};    //可以走八个方向
int dy[] = {-2, -1, 1, 2, 2, 1, -1, -2};

bool visited[100];

int main() {
    int t;
    cin &amp;gt;&amp;gt; t;
    while (t--) {
        memset(visited, false, sizeof(visited));
        int distance[100] = {0};

        string node1, node2;
        cin &amp;gt;&amp;gt; node1 &amp;gt;&amp;gt; node2;

        int X = (node1[0]-&#39;a&#39;)*8 + node1[1]-&#39;1&#39;;
        int Y = (node2[0]-&#39;a&#39;)*8 + node2[1]-&#39;1&#39;;

        queue&amp;lt;int&amp;gt; store;
        store.push(X);
        while (!store.empty()) {
            if (store.front() == Y)
                break;

            int x = store.front()/8;
            int y = store.front()%8;

            for (int i = 0; i &amp;lt; 8; i++) {
                int nx = x+dx[i];
                int ny = y+dy[i];
                
                if (nx &amp;lt; 0||nx &amp;gt; 7||ny &amp;lt; 0||ny &amp;gt; 7)
                    continue;
                int temp = nx*8 + ny;
                
                if (!visited[temp]) {
                    store.push(temp);
                    visited[temp] = true;
                    distance[temp] = distance[store.front()] + 1;
                }
            }
            store.pop();
        }
        cout &amp;lt;&amp;lt; &quot;To get from &quot; &amp;lt;&amp;lt; node1
             &amp;lt;&amp;lt; &quot; to &quot; &amp;lt;&amp;lt; node2 &amp;lt;&amp;lt; &quot; takes &quot;
             &amp;lt;&amp;lt; distance[Y] &amp;lt;&amp;lt; &quot; knight moves.\n&quot;;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily12/</link>
        <guid isPermaLink="true">/2016/03/04/sicily12/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily shortest path in unweighted graph</title>
        <description>&lt;ul&gt;
  &lt;li&gt;题目介绍：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;输入一个无向图，指定一个顶点s开始bfs遍历，求出s到图中每个点的最短距离。

如果不存在s到t的路径，则记s到t的距离为-1。
 
Input
输入的第一行包含两个整数n和m，n是图的顶点数，m是边数。1&amp;lt;=n&amp;lt;=1000，0&amp;lt;=m&amp;lt;=10000。

以下m行，每行是一个数对v y，表示存在边(v,y)。顶点编号从1开始。 
 
Output
记s=1，在一行中依次输出：顶点1到s的最短距离，顶点2到s的最短距离，...，顶点n到s的最短距离。

每项输出之后加一个空格，包括最后一项。
 
Sample Input
5 3
1 2
1 3
2 4
Sample Output
0 1 1 2 -1 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;利用广度搜索，标记层数，依次计算距离即可。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

bool path[1001][1001];
int shortest[1001];

int main() {
    int n, m;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    
    for (int i = 1; i &amp;lt;= m; i++) {
        int node1, node2;
        cin &amp;gt;&amp;gt; node1 &amp;gt;&amp;gt; node2;
        path[node1][node2] = true;
        path[node2][node1] = true;
    }
    
    for (int i = 1; i &amp;lt;= n; i++)
        i == 1 ? shortest[i] = 0 : shortest[i] = -1;
    
    int distance = 0;
    queue&amp;lt;int&amp;gt; store;
    store.push(1);
    while (!store.empty()) {
        int size = store.size();
        distance++;
        while (size--) {
            for (int i = 1; i &amp;lt;= n; i++) {
                if (path[store.front()][i] &amp;amp;&amp;amp; shortest[i] == -1) {
                    shortest[i] = distance;
                    store.push(i);
                }
            }
            store.pop();
        }
    }
    
    for (int i = 1; i &amp;lt;= n; i++)
        cout &amp;lt;&amp;lt; shortest[i] &amp;lt;&amp;lt; &quot; &quot;;
    cout &amp;lt;&amp;lt; endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily11/</link>
        <guid isPermaLink="true">/2016/03/04/sicily11/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily connect components in undirected graph</title>
        <description>&lt;ul&gt;
  &lt;li&gt;题目介绍：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;输入一个简单无向图，求出图中连通块的数目。

Input
输入的第一行包含两个整数n和m，n是图的顶点数，m是边数。1&amp;lt;=n&amp;lt;=1000，0&amp;lt;=m&amp;lt;=10000。

以下m行，每行是一个数对v y，表示存在边(v,y)。顶点编号从1开始。
Output
单独一行输出连通块的数目。

Sample Input
5 3
1 2
1 3
2 4
Sample Output
2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;利用广度搜索，计算广度搜索的次数即为结果。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

bool path[1001][1001];
bool visited[1001];

int main() {
    int n, m;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    
    for (int i = 0; i &amp;lt; m; i++) {
        int node1, node2;
        cin &amp;gt;&amp;gt; node1 &amp;gt;&amp;gt; node2;
        path[node1][node2] = true;
        path[node2][node1] = true;
    }
    
    for (int i = 1; i &amp;lt;= n; i++) {
        visited[i] = false;
    }
    
    int count = 0;
    int temp = n;
    while (temp--) {
        queue&amp;lt;int&amp;gt; store;
        for (int i = 1; i &amp;lt;= n; i++) {
            if (!visited[i]) {
                store.push(i);
                count++;
                visited[i] = true;
                break;
            }
        }
        
        while (!store.empty()) {
            for (int i = 1; i &amp;lt;= n; i++) {
                if (path[store.front()][i] &amp;amp;&amp;amp; !visited[i]) {
                    store.push(i);
                    visited[i] = true;
                }
            }
            store.pop();
        }
    }
    
    cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily10/</link>
        <guid isPermaLink="true">/2016/03/04/sicily10/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1931. 卡片游戏</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;纯属数据结构中队列的应用，可以练练手。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

int main() {
    int t;
    cin &amp;gt;&amp;gt; t;
    while (t--) {
        int num;
        cin &amp;gt;&amp;gt; num;
        queue&amp;lt;int&amp;gt; store;
        for (int i = 1; i &amp;lt;= num; i++) {
            store.push(i);
        }
        for (int i = 1; i &amp;lt;= num; i++) {
            cout &amp;lt;&amp;lt; store.front() &amp;lt;&amp;lt; &quot; &quot;;
            store.pop();
            int temp = store.front();
            store.pop();
            store.push(temp);
        }
        cout &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily-9/</link>
        <guid isPermaLink="true">/2016/03/04/sicily-9/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1021. Couples</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;想清楚了这道题其实很简单。利用夫妻出现的位置作为下标，并设为同一值，第一对夫妻值为1，第二对为2，以此类推，存储完毕即可进入下一步。&lt;/li&gt;
      &lt;li&gt;利用栈这个数据结构：遍历这个数组，当栈不为空且栈顶元素等于数组出现的元素时，pop掉栈顶元素，其余情况则入栈。循环完毕，若栈为空则为Yes，否则为No。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;
using namespace std;

int main() {
    int num;
    while (cin &amp;gt;&amp;gt; num &amp;amp;&amp;amp; num) {
        int *store = new int[num*2+1];
        for (int i = 1; i &amp;lt;= num; i++) {
            int a, b;
            cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
            store[a] = store[b] = i;
        }
        stack&amp;lt;int&amp;gt; st;
        for (int i = 1; i &amp;lt;= num*2; i++) {
            if (!st.empty() &amp;amp;&amp;amp; st.top() == store[i]) {
                st.pop();
            }
            else {
                st.push(store[i]);
            }
        }
        st.empty() ? cout &amp;lt;&amp;lt; &quot;Yes\n&quot; : cout &amp;lt;&amp;lt; &quot;No\n&quot;;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily-8/</link>
        <guid isPermaLink="true">/2016/03/04/sicily-8/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1129. ISBN</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;这道题比较简单，只要看懂题目就应该可以了。那就解释下题目好了，题目意思是按照权值计算这10个数字和，依据这个和计算还差多少可以对11整除，若还差10，那么在这个结尾加上“-X”，若不是10则输出“-”加上还差多少可以整除的那个数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

int Sum(string x) {
    int sum = 0;
    int weight = 10;
    for (int i = 0; i &amp;lt; x.size(); i++) {
        if (x[i] &amp;gt;= &#39;0&#39;&amp;amp;&amp;amp;x[i] &amp;lt;= &#39;9&#39;) {
            sum += (x[i]-&#39;0&#39;)*(weight--);
        }
    }
    return sum;
}

int main() {
    string test;
    while (cin &amp;gt;&amp;gt; test) {
        int sum = Sum(test);
        int check_digit = sum%11 == 0 ? 0 : 11-sum%11;
        check_digit == 10 ? cout &amp;lt;&amp;lt; test &amp;lt;&amp;lt; &quot;-X\n&quot;
            : cout &amp;lt;&amp;lt; test &amp;lt;&amp;lt; &quot;-&quot; &amp;lt;&amp;lt; check_digit &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily-7/</link>
        <guid isPermaLink="true">/2016/03/04/sicily-7/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1133. SPAM</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;题目意思是说在‘@’的前后出现题目给定的合法字符或者不连续出现‘.’字符的话，这个就是合理的输出。那么以@为中心，向前，向后扫描，当扫描到不符合字符时，记录此时位置，以前后为区间，输出字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

bool is_ok(char ch) {
    if ((ch &amp;gt;= &#39;A&#39;&amp;amp;&amp;amp;ch &amp;lt;= &#39;Z&#39;) || (ch &amp;gt;= &#39;a&#39;&amp;amp;&amp;amp;ch &amp;lt;= &#39;z&#39;) ||
        (ch &amp;gt;= &#39;0&#39;&amp;amp;&amp;amp;ch &amp;lt;= &#39;9&#39;) || ch == &#39;-&#39;||ch == &#39;_&#39;) {
           return true;
    }
    return false;
}

int main() {
    string test;
    while (getline(cin, test)) {
        if (test.size() == 0) continue;
        for (int i = 1; i &amp;lt; test.size()-1; i++) {
            if (test[i] == &#39;@&#39;&amp;amp;&amp;amp;is_ok(test[i-1])&amp;amp;&amp;amp;is_ok(test[i+1])) {
                int begin, end;
                for (begin = i-1; begin &amp;gt;= 0; begin--) {
                    if ((test[begin] == &#39;.&#39;&amp;amp;&amp;amp;test[begin+1] == &#39;.&#39;)) {
                        break;
                    }
                    if (test[begin] != &#39;.&#39;&amp;amp;&amp;amp;!is_ok(test[begin])) {
                        break;
                    }
                }
                if (test[begin+1] == &#39;.&#39;) begin++;
                for (end = i+1; end &amp;lt; test.size(); end++) {
                    if ((test[end] == &#39;.&#39;&amp;amp;&amp;amp;test[end-1] == &#39;.&#39;)) {
                        break;
                    }
                    if (test[end] != &#39;.&#39;&amp;amp;&amp;amp;!is_ok(test[end])) {
                        break;
                    }
                }
                if (test[end-1] == &#39;.&#39;) end--;
                for (int j = begin+1; j &amp;lt;= end-1; j++) {
                    cout &amp;lt;&amp;lt; test[j];
                }
                cout &amp;lt;&amp;lt; endl;
            }
        }
     }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily-6/</link>
        <guid isPermaLink="true">/2016/03/04/sicily-6/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1282. Computer Game</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;KMP算法，网上有很多资料，参考了一些网上的解题，收获很大，很感谢那些大神们！！！&lt;/li&gt;
      &lt;li&gt;通过这道题简单说说我对KMP算法的理解吧（大神们勿喷，虽然没人看我的orz~~~~囧）。&lt;/li&gt;
      &lt;li&gt;首先输入的是要匹配的字符串，如果这个字符串的首字母在整个字符串不重复出现的话，直接一直匹配下去即可。诶，那重复出现了怎么办，那就从最后一个重复出现的重新开始匹配，那么这就找到优化算法的好方法了，KMP算法的精髓大致是这样的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;

int main() {
    int len1, len2;
    while (cin &amp;gt;&amp;gt; len1) {
        int code[60001] = {0}; 
        int next[60001] = {0};
        for (int i = 1; i &amp;lt;= len1; i++) {
            scanf(&quot;%d&quot;, &amp;amp;code[i]);
        }
        int index = 0;
        for (int i = 2; i &amp;lt;= len1; i++) {
            index = code[index+1] == code[i] ? index+1 : 0;
            next[i] = index;
        }
        cin &amp;gt;&amp;gt; len2;
        index = 0;
        int test, result;
        for (int i = 1; i &amp;lt;= len2; i++) {
            scanf(&quot;%d&quot;, &amp;amp;test);
            if (index != len1) {
                index = code[index+1] == test ? index+1 : next[index];
                if (index == len1) {
                    result = i-len1;
                }
            }
        }
        index == len1 ? cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl : cout &amp;lt;&amp;lt; &quot;no solution\n&quot;;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily-5/</link>
        <guid isPermaLink="true">/2016/03/04/sicily-5/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1323. Switch text</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;题目意思不好理解呀。&lt;/li&gt;
      &lt;li&gt;题目意思是这样的：输入两个测试数据，首先，两个测试数据本身得各自前后倒转，然后两个测试数据倒转后的结果再各自对半互换，然后测试数据二先输出，测试数据一再输出，不断循环下去。还有一点很关键，就是对空行的判断，这个空行可以是空格组成，或者是直接回车，空行是忽略不输出的。还是直接看代码吧，这样好理解一点。用stl会使程序简化明了很多&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

int main() {
    int n, m;
    while (cin &amp;gt;&amp;gt; n &amp;amp;&amp;amp; n) {
        cin &amp;gt;&amp;gt; m;
        set&amp;lt;string&amp;gt; v;
        for (int i = 0; i &amp;lt; n; i++) {
            string temp;
            cin &amp;gt;&amp;gt; temp;
            for (int j = 0; j &amp;lt; temp.size(); j++) {  //全部转化为小写 
                temp[j] = tolower(temp[j]);
            }
            v.insert(temp);
        }
        for (int i = 0; i &amp;lt; m; i++) {
            string temp;
            cin &amp;gt;&amp;gt; temp;
            for (int j = 0; j &amp;lt; temp.size(); j++) {
                temp[j] = tolower(temp[j]);
            }
            if (v.count(temp))
                v.erase(temp); 
        }
        cout &amp;lt;&amp;lt; v.size() &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily-4/</link>
        <guid isPermaLink="true">/2016/03/04/sicily-4/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
  </channel>
</rss>
