<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Winray Blog</title>
    <description>For study!</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 06 Mar 2016 01:36:45 +0800</pubDate>
    <lastBuildDate>Sun, 06 Mar 2016 01:36:45 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>经典排序算法（二）</title>
        <description>
</description>
        <pubDate>Sun, 06 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/06/algorithm/</link>
        <guid isPermaLink="true">/2016/03/06/algorithm/</guid>
        
        <category>算法</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>经典排序算法（一）</title>
        <description>&lt;h5 id=&quot;section&quot;&gt;概述&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;是计算机程序设计中的一种重要操作，简单的说，可以使任意序列重新排列成一个按关键字有序的序列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;好处：
    &lt;ul&gt;
      &lt;li&gt;有序顺序可以采用查找效率较高的折半查找法&lt;/li&gt;
      &lt;li&gt;有如建造数表（无论是二叉树还是B-树）的过程本身就是一个排序的过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;section-1&quot;&gt;稳定与否&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;若两个相等数，在排序前与排序后的顺序相同，则是稳定的排序，否则是不稳定的。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;eg：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;假设:	 a = b
稳定:	 a, b --&amp;gt;  a, b
不稳定:  a, b --&amp;gt;  b, a
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;section-2&quot;&gt;内（/外）部排序&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;内部排序：指的是带排序的记录存放在计算机存储器中进行的排序过程
    &lt;ul&gt;
      &lt;li&gt;插入排序&lt;/li&gt;
      &lt;li&gt;交换排序&lt;/li&gt;
      &lt;li&gt;选择排序&lt;/li&gt;
      &lt;li&gt;归并排序&lt;/li&gt;
      &lt;li&gt;计数排序&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;外部排序：指的是带排序的记录数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-3&quot;&gt;两种基本操作&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;比较两个关键字的大小&lt;/li&gt;
  &lt;li&gt;将记录从一个位置移动至另外一个记录&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;排序算法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;下面正式介绍各种排序算法&lt;/li&gt;
  &lt;li&gt;都是从小到大排序&lt;/li&gt;
  &lt;li&gt;以整形为例&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;section-5&quot;&gt;插入排序&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;直接插入排序，是一种最简单的排序方法&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;基本操作是将一个记录插入到已排好的有序表中从而得到一个新的、记录数增1的有序表。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insertSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;c1&quot;&gt;//把比插入元素大的元素后移 
&lt;/span&gt;              &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;//找打合适位置插入 
&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;section-6&quot;&gt;希尔排序&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;类似与插入排序&lt;/li&gt;
  &lt;li&gt;改进：
    &lt;ul&gt;
      &lt;li&gt;通过比较相距一定间隔的元素来工作；&lt;/li&gt;
      &lt;li&gt;随着每一趟比较所用的距离随着算法的进行而减小；&lt;/li&gt;
      &lt;li&gt;直到只比较相邻元素的最后一趟排序位置。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为此，希尔排序有时也叫缩减增量排序。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void shellSort(int test[], int len) {
  for (int gap = len/2; gap &amp;gt; 0; gap /= 2) {
      //选取步长 
      for (int i = gap; i &amp;lt; len; i++) {
          //以步长进行的选择排序 
          int tmp = test[i], j;
          for (j = i; j &amp;gt;= gap &amp;amp;&amp;amp; tmp &amp;lt; test[j-gap]; j -= gap) {
              test[j] = test[j-gap];
          }
          //找到合适位置插入 
          test[j] = tmp;
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;section-7&quot;&gt;冒泡排序&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;每一轮都把这轮的最大放到最后的位置&lt;/li&gt;
  &lt;li&gt;如：
    &lt;ul&gt;
      &lt;li&gt;第一轮把最大的数字放到最后一位&lt;/li&gt;
      &lt;li&gt;第二轮把最大的数字放到倒数第二位&lt;/li&gt;
      &lt;li&gt;第三轮把最大的数字放到倒数第三位&lt;/li&gt;
      &lt;li&gt;以此类推&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void bubbleSort(int test[], int len) {
  for (int i = 1; i &amp;lt; len; i++) {
      //每一轮都把这轮最大的数放到（‘len-i’位置）
      for (int j = 0; j &amp;lt; len-i; j++) {
          if (test[j] &amp;gt; test[j+1]) {
              int tmp = test[j+1];
              test[j+1] = test[j];
              test[j] = tmp;			
          }
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;section-8&quot;&gt;选择排序&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;类似冒泡排序&lt;/li&gt;
  &lt;li&gt;但是交换次数减少，因为冒泡排序是通过每一次交换把数字替换，而选择排序是选出最小一位再交换，效果更好&lt;/li&gt;
  &lt;li&gt;找到每一轮的最小元素，然后替换，直到最后排序完成&lt;/li&gt;
  &lt;li&gt;如：
    &lt;ul&gt;
      &lt;li&gt;第一轮把最小的数字放到第一位&lt;/li&gt;
      &lt;li&gt;第二轮把最小的数字放到第二位&lt;/li&gt;
      &lt;li&gt;第三轮把最小的数字放到第三位&lt;/li&gt;
      &lt;li&gt;以此类推。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void selectSort(int test[], int len) {
  for (int i = 0; i &amp;lt; len; ++i) {
      //记录当前为最小元素 
      int index = i;
      //找到最小元素 
      for (int j = i+1; j &amp;lt; len; ++j) {
          if (test[j] &amp;lt; test[index]) {
              index = j;
          }
      }
      //如果找到的最小元素比记录的最小元素要小，那么替换当前最小元素 
      if (index != i) {
          int tmp = test[index];
          test[index] = test[i];
          test[i] = tmp;
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 05 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/05/algorithm/</link>
        <guid isPermaLink="true">/2016/03/05/algorithm/</guid>
        
        <category>算法</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1034. Forest</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;网上很多说用深搜，很任性…….发现广搜也挺好用的，实验课打的(⊙o⊙)…orz……..囧。&lt;/li&gt;
      &lt;li&gt;先找根结点，根据根结点广搜深度，广搜宽度，不过要开一个数组，同一层的累加宽度。别忘了要判断是否合法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

bool path[101][101];
bool visited[101];
bool Root[101];

int main()
{
    int n, m;
    while (cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;amp;&amp;amp; n)
    {
        memset(path, false, sizeof(path));
        memset(visited, false, sizeof(visited));
        memset(Root, true, sizeof(Root));

        bool flag = n &amp;gt; m ? true : false;
        for (int i = 1; i &amp;lt;= m; i++)
        {
            int node1, node2;
            cin &amp;gt;&amp;gt; node1 &amp;gt;&amp;gt; node2;
            if (node1 == node2) flag = false;
            path[node1][node2] = true;
        }
        if (flag == false) {
            cout &amp;lt;&amp;lt; &quot;INVALID\n&quot;;
            continue;
        }
        
        for (int i = 1; i &amp;lt;= n; i++)
            for (int j = 1; j &amp;lt;= n; j++)
                if (path[j][i])
                    Root[i] = false;
        int maxwidth = 0;
        for (int i = 1; i &amp;lt;= n; i++)
            if (Root[i]) {
                maxwidth++;
                visited[i] = true;
            }
        queue&amp;lt;int&amp;gt; store;
        int depth, maxdepth;
        maxdepth = depth = 0;
        int width[101] = {0};
        for (int i = 1; i &amp;lt;= n; i++)
        {
            if (Root[i])
            {
                store.push(i);
                depth = 0;
                while (!store.empty())
                {
                    int size = store.size();
                    width[depth] += size;
                    while (size--)
                    {
                        for (int j = 1; j &amp;lt;= n; j++)
                            if (path[store.front()][j])
                            {
                                if (!visited[j]) {
                                    store.push(j);
                                    visited[j] = true;
                                }
                                else
                                    flag = false;
                            }
                        store.pop();
                    }
                    if (!store.empty())
                        depth++;
                }
                maxdepth = depth &amp;gt; maxdepth ? depth : maxdepth;
            }
        }
        
        for (int i = 1; i &amp;lt;= n; i++)
            if (!visited[i]) {
                flag = false;
                break;
            }
        
        for (int i = 0; i &amp;lt;= maxdepth; i++)
            maxwidth = width[i] &amp;gt; maxwidth ? width[i] : maxwidth;
        
        flag == false ? cout &amp;lt;&amp;lt; &quot;INVALID&quot; : cout &amp;lt;&amp;lt; maxdepth &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; maxwidth;
        cout &amp;lt;&amp;lt; endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily13/</link>
        <guid isPermaLink="true">/2016/03/04/sicily13/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1936. Knight Moves</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;这道题一开始不理解题意…orz…囧，看大神们理解的。&lt;/li&gt;
      &lt;li&gt;题意是说一个8*8的国际象棋，骑士以马的形式走动（“日”字型），指定两个点，输出最小的步骤。&lt;/li&gt;
      &lt;li&gt;可以利用广度搜索解决。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

int dx[] = {-1, -2, -2, -1, 1, 2, 2, 1};    //可以走八个方向
int dy[] = {-2, -1, 1, 2, 2, 1, -1, -2};

bool visited[100];

int main() {
    int t;
    cin &amp;gt;&amp;gt; t;
    while (t--) {
        memset(visited, false, sizeof(visited));
        int distance[100] = {0};

        string node1, node2;
        cin &amp;gt;&amp;gt; node1 &amp;gt;&amp;gt; node2;

        int X = (node1[0]-&#39;a&#39;)*8 + node1[1]-&#39;1&#39;;
        int Y = (node2[0]-&#39;a&#39;)*8 + node2[1]-&#39;1&#39;;

        queue&amp;lt;int&amp;gt; store;
        store.push(X);
        while (!store.empty()) {
            if (store.front() == Y)
                break;

            int x = store.front()/8;
            int y = store.front()%8;

            for (int i = 0; i &amp;lt; 8; i++) {
                int nx = x+dx[i];
                int ny = y+dy[i];
                
                if (nx &amp;lt; 0||nx &amp;gt; 7||ny &amp;lt; 0||ny &amp;gt; 7)
                    continue;
                int temp = nx*8 + ny;
                
                if (!visited[temp]) {
                    store.push(temp);
                    visited[temp] = true;
                    distance[temp] = distance[store.front()] + 1;
                }
            }
            store.pop();
        }
        cout &amp;lt;&amp;lt; &quot;To get from &quot; &amp;lt;&amp;lt; node1
             &amp;lt;&amp;lt; &quot; to &quot; &amp;lt;&amp;lt; node2 &amp;lt;&amp;lt; &quot; takes &quot;
             &amp;lt;&amp;lt; distance[Y] &amp;lt;&amp;lt; &quot; knight moves.\n&quot;;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily12/</link>
        <guid isPermaLink="true">/2016/03/04/sicily12/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily shortest path in unweighted graph</title>
        <description>&lt;ul&gt;
  &lt;li&gt;题目介绍：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;输入一个无向图，指定一个顶点s开始bfs遍历，求出s到图中每个点的最短距离。

如果不存在s到t的路径，则记s到t的距离为-1。
 
Input
输入的第一行包含两个整数n和m，n是图的顶点数，m是边数。1&amp;lt;=n&amp;lt;=1000，0&amp;lt;=m&amp;lt;=10000。

以下m行，每行是一个数对v y，表示存在边(v,y)。顶点编号从1开始。 
 
Output
记s=1，在一行中依次输出：顶点1到s的最短距离，顶点2到s的最短距离，...，顶点n到s的最短距离。

每项输出之后加一个空格，包括最后一项。
 
Sample Input
5 3
1 2
1 3
2 4
Sample Output
0 1 1 2 -1 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;利用广度搜索，标记层数，依次计算距离即可。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

bool path[1001][1001];
int shortest[1001];

int main() {
    int n, m;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    
    for (int i = 1; i &amp;lt;= m; i++) {
        int node1, node2;
        cin &amp;gt;&amp;gt; node1 &amp;gt;&amp;gt; node2;
        path[node1][node2] = true;
        path[node2][node1] = true;
    }
    
    for (int i = 1; i &amp;lt;= n; i++)
        i == 1 ? shortest[i] = 0 : shortest[i] = -1;
    
    int distance = 0;
    queue&amp;lt;int&amp;gt; store;
    store.push(1);
    while (!store.empty()) {
        int size = store.size();
        distance++;
        while (size--) {
            for (int i = 1; i &amp;lt;= n; i++) {
                if (path[store.front()][i] &amp;amp;&amp;amp; shortest[i] == -1) {
                    shortest[i] = distance;
                    store.push(i);
                }
            }
            store.pop();
        }
    }
    
    for (int i = 1; i &amp;lt;= n; i++)
        cout &amp;lt;&amp;lt; shortest[i] &amp;lt;&amp;lt; &quot; &quot;;
    cout &amp;lt;&amp;lt; endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily11/</link>
        <guid isPermaLink="true">/2016/03/04/sicily11/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily connect components in undirected graph</title>
        <description>&lt;ul&gt;
  &lt;li&gt;题目介绍：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;输入一个简单无向图，求出图中连通块的数目。

Input
输入的第一行包含两个整数n和m，n是图的顶点数，m是边数。1&amp;lt;=n&amp;lt;=1000，0&amp;lt;=m&amp;lt;=10000。

以下m行，每行是一个数对v y，表示存在边(v,y)。顶点编号从1开始。
Output
单独一行输出连通块的数目。

Sample Input
5 3
1 2
1 3
2 4
Sample Output
2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;利用广度搜索，计算广度搜索的次数即为结果。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

bool path[1001][1001];
bool visited[1001];

int main() {
    int n, m;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    
    for (int i = 0; i &amp;lt; m; i++) {
        int node1, node2;
        cin &amp;gt;&amp;gt; node1 &amp;gt;&amp;gt; node2;
        path[node1][node2] = true;
        path[node2][node1] = true;
    }
    
    for (int i = 1; i &amp;lt;= n; i++) {
        visited[i] = false;
    }
    
    int count = 0;
    int temp = n;
    while (temp--) {
        queue&amp;lt;int&amp;gt; store;
        for (int i = 1; i &amp;lt;= n; i++) {
            if (!visited[i]) {
                store.push(i);
                count++;
                visited[i] = true;
                break;
            }
        }
        
        while (!store.empty()) {
            for (int i = 1; i &amp;lt;= n; i++) {
                if (path[store.front()][i] &amp;amp;&amp;amp; !visited[i]) {
                    store.push(i);
                    visited[i] = true;
                }
            }
            store.pop();
        }
    }
    
    cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily10/</link>
        <guid isPermaLink="true">/2016/03/04/sicily10/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1931. 卡片游戏</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;纯属数据结构中队列的应用，可以练练手。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

int main() {
    int t;
    cin &amp;gt;&amp;gt; t;
    while (t--) {
        int num;
        cin &amp;gt;&amp;gt; num;
        queue&amp;lt;int&amp;gt; store;
        for (int i = 1; i &amp;lt;= num; i++) {
            store.push(i);
        }
        for (int i = 1; i &amp;lt;= num; i++) {
            cout &amp;lt;&amp;lt; store.front() &amp;lt;&amp;lt; &quot; &quot;;
            store.pop();
            int temp = store.front();
            store.pop();
            store.push(temp);
        }
        cout &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily-9/</link>
        <guid isPermaLink="true">/2016/03/04/sicily-9/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1021. Couples</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;想清楚了这道题其实很简单。利用夫妻出现的位置作为下标，并设为同一值，第一对夫妻值为1，第二对为2，以此类推，存储完毕即可进入下一步。&lt;/li&gt;
      &lt;li&gt;利用栈这个数据结构：遍历这个数组，当栈不为空且栈顶元素等于数组出现的元素时，pop掉栈顶元素，其余情况则入栈。循环完毕，若栈为空则为Yes，否则为No。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;
using namespace std;

int main() {
    int num;
    while (cin &amp;gt;&amp;gt; num &amp;amp;&amp;amp; num) {
        int *store = new int[num*2+1];
        for (int i = 1; i &amp;lt;= num; i++) {
            int a, b;
            cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
            store[a] = store[b] = i;
        }
        stack&amp;lt;int&amp;gt; st;
        for (int i = 1; i &amp;lt;= num*2; i++) {
            if (!st.empty() &amp;amp;&amp;amp; st.top() == store[i]) {
                st.pop();
            }
            else {
                st.push(store[i]);
            }
        }
        st.empty() ? cout &amp;lt;&amp;lt; &quot;Yes\n&quot; : cout &amp;lt;&amp;lt; &quot;No\n&quot;;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily-8/</link>
        <guid isPermaLink="true">/2016/03/04/sicily-8/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1129. ISBN</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;这道题比较简单，只要看懂题目就应该可以了。那就解释下题目好了，题目意思是按照权值计算这10个数字和，依据这个和计算还差多少可以对11整除，若还差10，那么在这个结尾加上“-X”，若不是10则输出“-”加上还差多少可以整除的那个数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

int Sum(string x) {
    int sum = 0;
    int weight = 10;
    for (int i = 0; i &amp;lt; x.size(); i++) {
        if (x[i] &amp;gt;= &#39;0&#39;&amp;amp;&amp;amp;x[i] &amp;lt;= &#39;9&#39;) {
            sum += (x[i]-&#39;0&#39;)*(weight--);
        }
    }
    return sum;
}

int main() {
    string test;
    while (cin &amp;gt;&amp;gt; test) {
        int sum = Sum(test);
        int check_digit = sum%11 == 0 ? 0 : 11-sum%11;
        check_digit == 10 ? cout &amp;lt;&amp;lt; test &amp;lt;&amp;lt; &quot;-X\n&quot;
            : cout &amp;lt;&amp;lt; test &amp;lt;&amp;lt; &quot;-&quot; &amp;lt;&amp;lt; check_digit &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily-7/</link>
        <guid isPermaLink="true">/2016/03/04/sicily-7/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>Sicily 1133. SPAM</title>
        <description>&lt;ul&gt;
  &lt;li&gt;思路：
    &lt;ul&gt;
      &lt;li&gt;题目意思是说在‘@’的前后出现题目给定的合法字符或者不连续出现‘.’字符的话，这个就是合理的输出。那么以@为中心，向前，向后扫描，当扫描到不符合字符时，记录此时位置，以前后为区间，输出字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;具体代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

bool is_ok(char ch) {
    if ((ch &amp;gt;= &#39;A&#39;&amp;amp;&amp;amp;ch &amp;lt;= &#39;Z&#39;) || (ch &amp;gt;= &#39;a&#39;&amp;amp;&amp;amp;ch &amp;lt;= &#39;z&#39;) ||
        (ch &amp;gt;= &#39;0&#39;&amp;amp;&amp;amp;ch &amp;lt;= &#39;9&#39;) || ch == &#39;-&#39;||ch == &#39;_&#39;) {
           return true;
    }
    return false;
}

int main() {
    string test;
    while (getline(cin, test)) {
        if (test.size() == 0) continue;
        for (int i = 1; i &amp;lt; test.size()-1; i++) {
            if (test[i] == &#39;@&#39;&amp;amp;&amp;amp;is_ok(test[i-1])&amp;amp;&amp;amp;is_ok(test[i+1])) {
                int begin, end;
                for (begin = i-1; begin &amp;gt;= 0; begin--) {
                    if ((test[begin] == &#39;.&#39;&amp;amp;&amp;amp;test[begin+1] == &#39;.&#39;)) {
                        break;
                    }
                    if (test[begin] != &#39;.&#39;&amp;amp;&amp;amp;!is_ok(test[begin])) {
                        break;
                    }
                }
                if (test[begin+1] == &#39;.&#39;) begin++;
                for (end = i+1; end &amp;lt; test.size(); end++) {
                    if ((test[end] == &#39;.&#39;&amp;amp;&amp;amp;test[end-1] == &#39;.&#39;)) {
                        break;
                    }
                    if (test[end] != &#39;.&#39;&amp;amp;&amp;amp;!is_ok(test[end])) {
                        break;
                    }
                }
                if (test[end-1] == &#39;.&#39;) end--;
                for (int j = begin+1; j &amp;lt;= end-1; j++) {
                    cout &amp;lt;&amp;lt; test[j];
                }
                cout &amp;lt;&amp;lt; endl;
            }
        }
     }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/04/sicily-6/</link>
        <guid isPermaLink="true">/2016/03/04/sicily-6/</guid>
        
        <category>sicily</category>
        
        <category>c++</category>
        
        
      </item>
    
  </channel>
</rss>
